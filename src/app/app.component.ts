import { Component, ViewChild, AfterViewInit, ChangeDetectorRef, HostListener, ElementRef } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { CommonModule } from '@angular/common';
import { 
  FFlowModule, 
  FCreateNodeEvent, 
  FExternalItemDirective, 
  FExternalItemPlaceholderDirective, 
  FExternalItemPreviewDirective,
  FCanvasComponent
} from '@foblex/flow';
import { generateGuid } from '@foblex/utils';
import { BuilderComponent } from './components/builder/builder.component';

interface CrmNode {
  id: string;
  type: string;
  text: string;
  position: { x: number; y: number };
}

interface Connection {
  id: string;
  sourceId: string;
  targetId: string;
}

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    RouterOutlet,
    FFlowModule, 
    CommonModule, 
    BuilderComponent
  ],
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements AfterViewInit {
  title = 'study-foblex';
  
  @ViewChild(FCanvasComponent) canvas!: FCanvasComponent;
  
  // Tableau des n≈ìuds du CRM
  nodes: CrmNode[] = [];
  
  // Tableau des connexions entre les n≈ìuds
  connections: Connection[] = [];
  
  // N≈ìuds temporaires pour les emplacements potentiels
  temporaryNodes: CrmNode[] = [];
  
  // Connexions temporaires
  temporaryConnections: Connection[] = [];
  
  // Type de composant en cours de drag
  draggingItemType: string | null = null;
  
  // Un flag pour emp√™cher la cr√©ation multiple de n≈ìuds lors d'un drop
  isCreatingNode = false;
  
  // √âtat de la sidebar (ouvert par d√©faut)
  isSidebarOpen = true;
  
  constructor(private changeDetectorRef: ChangeDetectorRef, private elementRef: ElementRef) {}
  
  // D√©tection globale de fin de drag
  @HostListener('document:pointerup', ['$event'])
  onDocumentPointerUp(event: PointerEvent): void {
    if (this.draggingItemType && !this.isCreatingNode) {
      // V√©rifier si l'√©l√©ment sous le pointeur est un n≈ìud temporaire
      const elementsAtPoint = document.elementsFromPoint(event.clientX, event.clientY);
      
      // Chercher un √©l√©ment qui est un n≈ìud temporaire
      const temporaryNodeElement = elementsAtPoint.find(el => 
        el.classList.contains('temporary-node') || el.closest('.temporary-node') !== null
      );
      
      if (temporaryNodeElement) {
        // Trouver l'ID du n≈ìud temporaire
        const temporaryNode = temporaryNodeElement.classList.contains('temporary-node') 
          ? temporaryNodeElement 
          : temporaryNodeElement.closest('.temporary-node');
        
        if (temporaryNode) {
          // Extraire l'ID du n≈ìud temporaire de l'attribut data-node-id
          const nodeId = temporaryNode.getAttribute('data-node-id');
          if (nodeId) {
            console.log('Drop detected over temporary node:', nodeId);
            this.onDropOnTemporaryNode(nodeId);
            return;
          }
        }
      }
      
      // Si on n'est pas sur un n≈ìud temporaire, terminer le drag sans cr√©er de n≈ìud
      console.log('Not over a temporary node, ending drag without creating node');
      this.onDragEnd();
    }
  }
  
  @HostListener('window:fCreateNode', ['$event'])
  onGlobalCreateNode(event: CustomEvent): void {
    if (this.draggingItemType && !this.isCreatingNode) {
      console.log('Intercepted global fCreateNode event during drag, preventing default');
      
      // Emp√™cher la cr√©ation du n≈ìud
      event.preventDefault();
      event.stopPropagation();
      
      // Supprimer imm√©diatement tout √©l√©ment cr√©√©
      setTimeout(() => {
        const newElements = document.querySelectorAll('.f-external-item-placeholder');
        newElements.forEach(el => el.remove());
        
        // Forcer la fin du drag si le drop n'est pas sur un n≈ìud temporaire
        this.onDragEnd();
      }, 0);
    }
  }
  
  ngAfterViewInit() {
    console.log('Canvas component:', this.canvas);
    
    // Add a default node on initialization
    this.addDefaultNode();
    
    // R√©initialiser l'√©chelle et centrer le canvas
    setTimeout(() => {
      if (this.canvas) {
        this.canvas.resetScaleAndCenter(false);
      }
    }, 100);
  }
  
  // Method to add a default node
  private addDefaultNode(): void {
    // Create first node (Client)
    const clientNode: CrmNode = {
      id: generateGuid(),
      type: 'Client',
      text: 'Client 1',
      position: { x: 100, y: 100 }
    };
    
    // Create second node (Task)
    const taskNode: CrmNode = {
      id: generateGuid(),
      type: 'Task',
      text: 'Task 1',
      position: { x: 350, y: 100 }
    };
    
    // Add nodes to the nodes array
    this.nodes.push(clientNode, taskNode);
    
    // Create a connection between the nodes
    const connection: Connection = {
      id: generateGuid(),
      sourceId: `output_${clientNode.id}`,
      targetId: `input_${taskNode.id}`
    };
    
    // Add connection to the connections array
    this.connections.push(connection);
    
    console.log('Default nodes created:', clientNode, taskNode);
    console.log('Default connection created:', connection);
    
    // Force UI update
    this.changeDetectorRef.markForCheck();
  }
  
  // M√©thode pour cr√©er un nouveau n≈ìud
  onCreateNode(event: any): void {
    console.log('Create node event received:', event);
    
    // Ne rien faire si nous sommes en train de faire un drag
    if (this.draggingItemType || this.isCreatingNode) {
      console.log('Blocking node creation because we are dragging an item or already creating a node');
      // Emp√™cher la cr√©ation du n≈ìud et tout traitement ult√©rieur
      event.preventDefault?.();
      event.stopPropagation?.();
      
      // Supprimer imm√©diatement tout √©l√©ment qui pourrait avoir √©t√© cr√©√©
      setTimeout(() => {
        const newElements = document.querySelectorAll('.f-external-item-placeholder');
        newElements.forEach(el => {
          el.remove();
        });
      }, 0);
      
      return;
    }
    
    // Proc√©der avec la cr√©ation de n≈ìud normale seulement si nous ne sommes pas en drag
    if (!event) {
      console.error('Invalid event object:', event);
      return;
    }
    
    try {
      const nodeType = event.data as string || 'Default';
      
      console.log('Node type:', nodeType);
      console.log('Node position:', event.rect);
      
      const newNode: CrmNode = {
        id: generateGuid(),
        type: nodeType,
        text: `${nodeType} ${this.nodes.length + 1}`,
        position: event.rect
      };
      
      this.nodes.push(newNode);
      console.log('Node created:', newNode);
      console.log('Current nodes:', this.nodes);
      
      // Force la mise √† jour de la vue
      this.changeDetectorRef.markForCheck();
    } catch (error) {
      console.error('Error creating node:', error);
    }
  }
  
  // M√©thode pour obtenir l'ic√¥ne correspondant au type de n≈ìud
  getNodeIcon(type: string): string {
    const icons: { [key: string]: string } = {
      'Client': 'üë§',
      'Contact': 'üìû',
      'Deal': 'üí∞',
      'Task': '‚úÖ',
      'Email': '‚úâÔ∏è',
      'Default': 'üìÑ'
    };
    
    return icons[type] || icons['Default'];
  }
  
  // M√©thode pour obtenir les classes CSS en fonction du type de n≈ìud
  getNodeClass(type: string): string {
    const baseClasses = 'min-w-[180px] rounded-md shadow-md overflow-hidden';
    
    const typeClasses: { [key: string]: string } = {
      'Client': 'bg-blue-500',
      'Contact': 'bg-green-500',
      'Deal': 'bg-yellow-500',
      'Task': 'bg-red-500',
      'Email': 'bg-purple-500',
      'Default': 'bg-gray-500'
    };
    
    return `${baseClasses} ${typeClasses[type] || typeClasses['Default']}`;
  }
  
  // M√©thode pour g√©rer l'√©tat de la sidebar
  toggleSidebar(isOpen: boolean): void {
    this.isSidebarOpen = isOpen;
  }
  
  // M√©thode appel√©e quand un √©l√©ment commence √† √™tre dragg√© depuis le builder
  onDragStart(itemType: string): void {
    console.log('Drag started with item type:', itemType);
    this.draggingItemType = itemType;
    
    // Cr√©er des n≈ìuds temporaires pour montrer les emplacements potentiels
    this.createTemporaryNodes(itemType);
    
    // Force la mise √† jour de la vue avec setTimeout pour s'assurer que le changement est pris en compte
    setTimeout(() => {
      this.changeDetectorRef.detectChanges();
      console.log('Force UI update with temporary nodes:', this.temporaryNodes.length);
    }, 50);
  }
  
  // M√©thode appel√©e quand un drag se termine (abandon ou drop ailleurs)
  onDragEnd(): void {
    console.log('Drag ended without valid drop');
    
    // Nettoyer les n≈ìuds et connexions temporaires
    this.clearTemporaryElements();
    
    // R√©initialiser l'√©tat
    this.draggingItemType = null;
    
    // Supprimer tout √©l√©ment qui aurait pu √™tre cr√©√© par le syst√®me de drag standard
    // (s'assurer qu'aucun n≈ìud n'a √©t√© cr√©√© par erreur)
    setTimeout(() => {
      // Supprimer les √©l√©ments avec la classe 'f-external-item-placeholder' qui ont √©t√© cr√©√©s par le syst√®me de drag
      const placeholders = document.querySelectorAll('.f-external-item-placeholder');
      placeholders.forEach(el => {
        el.remove();
      });
      
      // R√©initialiser le flag de cr√©ation de n≈ìud
      this.isCreatingNode = false;
      
      // Force la mise √† jour de la vue
      this.changeDetectorRef.detectChanges();
      console.log('Drag end UI updated');
    }, 50);
  }
  
  // M√©thode appel√©e quand un √©l√©ment est d√©pos√© sur un n≈ìud temporaire
  onDropOnTemporaryNode(temporaryNodeId: string): void {
    console.log('Dropped on temporary node:', temporaryNodeId);
    
    // Si nous sommes d√©j√† en train de cr√©er un n≈ìud, ne rien faire
    if (this.isCreatingNode) {
      console.log('Node creation already in progress, ignoring duplicate drop');
      return;
    }
    
    // Marquer que nous commen√ßons la cr√©ation d'un n≈ìud
    this.isCreatingNode = true;
    
    if (!this.draggingItemType) {
      this.clearTemporaryElements();
      this.isCreatingNode = false;
      return;
    }
    
    // Trouver le n≈ìud temporaire concern√©
    const temporaryNode = this.temporaryNodes.find(node => node.id === temporaryNodeId);
    if (!temporaryNode) {
      this.clearTemporaryElements();
      this.isCreatingNode = false;
      return;
    }
    
    // Trouver les connexions temporaires associ√©es √† ce n≈ìud
    const relatedTemporaryConnections = this.temporaryConnections.filter(
      conn => conn.sourceId === `output_${temporaryNodeId}` || conn.targetId === `input_${temporaryNodeId}`
    );
    
    // Cr√©er un n≈ìud permanent √† la place du n≈ìud temporaire
    const permanentNode: CrmNode = {
      id: generateGuid(),
      type: this.draggingItemType,
      text: `${this.draggingItemType} ${this.nodes.length + 1}`,
      position: { ...temporaryNode.position }
    };
    
    // Ajouter le n≈ìud permanent
    this.nodes.push(permanentNode);
    
    // Cr√©er des connexions permanentes pour remplacer les temporaires
    for (const tempConn of relatedTemporaryConnections) {
      const permanentConnection: Connection = {
        id: generateGuid(),
        sourceId: tempConn.sourceId.includes(temporaryNodeId) 
          ? `output_${permanentNode.id}` 
          : tempConn.sourceId,
        targetId: tempConn.targetId.includes(temporaryNodeId) 
          ? `input_${permanentNode.id}` 
          : tempConn.targetId
      };
      
      this.connections.push(permanentConnection);
    }
    
    // Nettoyer les √©l√©ments temporaires
    this.clearTemporaryElements();
    
    // R√©initialiser l'√©tat
    this.draggingItemType = null;
    
    // Supprimer tout √©l√©ment de placeholder qui aurait pu √™tre cr√©√© par le syst√®me de drag-and-drop de Foblex
    setTimeout(() => {
      const placeholders = document.querySelectorAll('.f-external-item-placeholder');
      placeholders.forEach(el => el.remove());
      
      // Force la mise √† jour de la vue
      this.changeDetectorRef.detectChanges();
      
      // R√©initialiser le flag de cr√©ation de n≈ìud
      this.isCreatingNode = false;
    }, 50);
  }
  
  // Cr√©er des n≈ìuds temporaires pour les emplacements potentiels de connexion
  private createTemporaryNodes(itemType: string): void {
    console.log('Creating temporary nodes for item type:', itemType);
    
    // D'abord, nettoyer les anciens n≈ìuds temporaires
    this.clearTemporaryElements();
    
    // Pour chaque n≈ìud existant, cr√©er un n≈ìud temporaire qui pourrait s'y connecter
    if (this.nodes.length === 0) {
      console.log('No existing nodes to create temporary connections to');
      
      // Cr√©er un n≈ìud temporaire au centre si aucun n≈ìud n'existe
      const centralTempNode: CrmNode = {
        id: `temp_central_${generateGuid()}`,
        type: itemType,
        text: `${itemType} (Drop here)`,
        position: { x: 400, y: 300 }
      };
      
      this.temporaryNodes.push(centralTempNode);
      return;
    }
    
    for (const existingNode of this.nodes) {
      console.log('Creating temporary nodes around existing node:', existingNode.id);
      
      // Cr√©er un n≈ìud temporaire √† droite du n≈ìud existant
      const rightTempNode: CrmNode = {
        id: `temp_right_${generateGuid()}`,
        type: itemType,
        text: `${itemType} (Drop here to connect)`,
        position: { 
          x: existingNode.position.x + 250, 
          y: existingNode.position.y 
        }
      };
      
      // Cr√©er un n≈ìud temporaire √† gauche du n≈ìud existant
      const leftTempNode: CrmNode = {
        id: `temp_left_${generateGuid()}`,
        type: itemType,
        text: `${itemType} (Drop here to connect)`,
        position: { 
          x: existingNode.position.x - 250, 
          y: existingNode.position.y 
        }
      };
      
      // V√©rifier que les positions ne se superposent pas avec des n≈ìuds existants
      // (ne pas ajouter si un n≈ìud existe d√©j√† √† cette position ou tr√®s proche)
      const isPositionFree = (position: {x: number, y: number}): boolean => {
        return !this.nodes.some(n => 
          Math.abs(n.position.x - position.x) < 100 && 
          Math.abs(n.position.y - position.y) < 100
        );
      };
      
      // N'ajouter que les n≈ìuds temporaires qui ne se superposent pas
      if (isPositionFree(rightTempNode.position)) {
        this.temporaryNodes.push(rightTempNode);
        
        // Cr√©er une connexion temporaire pour le n≈ìud √† droite
        const rightConnection: Connection = {
          id: `temp_conn_${generateGuid()}`,
          sourceId: `output_${existingNode.id}`,
          targetId: `input_${rightTempNode.id}`
        };
        this.temporaryConnections.push(rightConnection);
      }
      
      if (isPositionFree(leftTempNode.position)) {
        this.temporaryNodes.push(leftTempNode);
        
        // Cr√©er une connexion temporaire pour le n≈ìud √† gauche
        const leftConnection: Connection = {
          id: `temp_conn_${generateGuid()}`,
          sourceId: `output_${leftTempNode.id}`,
          targetId: `input_${existingNode.id}`
        };
        this.temporaryConnections.push(leftConnection);
      }
    }
    
    console.log('Created temporary nodes:', this.temporaryNodes.length);
    console.log('Created temporary connections:', this.temporaryConnections.length);
  }
  
  // Nettoyer les n≈ìuds et connexions temporaires
  private clearTemporaryElements(): void {
    console.log('Clearing temporary elements');
    this.temporaryNodes = [];
    this.temporaryConnections = [];
    
    // Force la mise √† jour de la vue
    setTimeout(() => {
      this.changeDetectorRef.detectChanges();
      console.log('Temporary nodes cleared');
    }, 50);
  }
  
  // M√©thode appel√©e lorsqu'un √©v√©nement pointerup se produit sur le canvas
  onCanvasPointerUp(event: PointerEvent): void {
    if (this.draggingItemType && !this.isCreatingNode) {
      console.log('Canvas pointerup event detected during drag');
      
      // Bloquer l'√©v√©nement pour emp√™cher toute propagation
      event.preventDefault();
      event.stopPropagation();
      
      // V√©rifier si l'√©l√©ment sous le pointeur est un n≈ìud temporaire
      const elementsAtPoint = document.elementsFromPoint(event.clientX, event.clientY);
      
      // Chercher un n≈ìud temporaire
      const temporaryNodeElement = elementsAtPoint.find(el => 
        el.classList.contains('temporary-node') || el.closest('.temporary-node') !== null
      );
      
      if (temporaryNodeElement) {
        // Trouver l'ID du n≈ìud temporaire
        const temporaryNode = temporaryNodeElement.classList.contains('temporary-node') 
          ? temporaryNodeElement 
          : temporaryNodeElement.closest('.temporary-node');
        
        if (temporaryNode) {
          // Extraire l'ID du n≈ìud temporaire
          const nodeId = temporaryNode.getAttribute('data-node-id');
          if (nodeId) {
            console.log('Drop detected over temporary node:', nodeId);
            
            // Cr√©er imm√©diatement le n≈ìud
            this.onDropOnTemporaryNode(nodeId);
            return;
          }
        }
      }
      
      console.log('Canvas pointer up occurred outside a temporary node, cleaning up');
      
      // Supprimer imm√©diatement tout √©l√©ment cr√©√© et terminer le drag
      setTimeout(() => {
        // Supprimer les √©l√©ments avec la classe 'f-external-item-placeholder'
        const placeholders = document.querySelectorAll('.f-external-item-placeholder');
        placeholders.forEach(el => el.remove());
        
        this.onDragEnd();
      }, 0);
    }
  }
  
  // M√©thode pour manipuler les √©v√©nements de Flow
  @HostListener('window:mouseup', ['$event'])
  handleFlowEvent(event: MouseEvent): void {
    if (this.draggingItemType && !this.isCreatingNode) {
      console.log('Global mouse up event during drag');
      
      // Bloquer compl√®tement les √©v√©nements de cr√©ation lors du drag
      event.stopPropagation();
      
      // Obtenir tous les √©l√©ments √† la position du clic
      const elementsAtPoint = document.elementsFromPoint(event.clientX, event.clientY);
      
      // V√©rifier si un n≈ìud temporaire se trouve √† cet endroit
      const temporaryNodeElement = elementsAtPoint.find(el => 
        el.classList.contains('temporary-node') || el.closest('.temporary-node') !== null
      );
      
      if (temporaryNodeElement) {
        // Trouver l'ID du n≈ìud temporaire
        const temporaryNode = temporaryNodeElement.classList.contains('temporary-node') 
          ? temporaryNodeElement 
          : temporaryNodeElement.closest('.temporary-node');
        
        if (temporaryNode) {
          // Extraire l'ID du n≈ìud temporaire de l'attribut data-node-id
          const nodeId = temporaryNode.getAttribute('data-node-id');
          if (nodeId) {
            console.log('Drop detected over temporary node:', nodeId);
            this.onDropOnTemporaryNode(nodeId);
            return;
          }
        }
      }
      
      // Si nous ne sommes pas sur un n≈ìud temporaire, annuler le drag et supprimer tout node plac√©
      console.log('Mouse up occurred outside a temporary node, cleaning up');
      
      // Supprimer imm√©diatement tout √©l√©ment cr√©√©
      setTimeout(() => {
        // Supprimer les √©l√©ments cr√©√©s par le syst√®me de drag externe
        const newElements = document.querySelectorAll('.f-external-item-placeholder');
        newElements.forEach(el => el.remove());
        
        this.onDragEnd();
      }, 0);
    }
  }
}
